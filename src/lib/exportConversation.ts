import { Message } from '../components/MessageList';

declare global {
  interface Window {
    Telegram?: {
      WebApp: any;
    };
  }
}

export function exportConversation(messages: Message[], language: 'en' | 'ru'): string {
  const title = language === 'ru' ? 'Разговор с Sobesednik' : 'Conversation with Sobesednik';
  const timestamp = new Date().toLocaleString(language === 'ru' ? 'ru-RU' : 'en-US');
  
  let output = `${title}\n`;
  output += `${timestamp}\n`;
  output += `${'─'.repeat(50)}\n\n`;

  messages.forEach((message, index) => {
    if (message.type === 'user') {
      output += `→ ${message.content}\n\n`;
    } else {
      output += `${message.content}\n\n`;
    }
    
    // Add subtle separator between exchanges (not after last message)
    if (index < messages.length - 1 && message.type === 'assistant') {
      output += `\n`;
    }
  });

  output += `\n${'─'.repeat(50)}\n`;
  output += language === 'ru' 
    ? `Сгенерировано Sobesednik — пространство для размышлений` 
    : `Generated by Sobesednik — a space for reflection`;

  return output;
}

export function downloadConversation(messages: Message[], language: 'en' | 'ru') {
  // In Telegram, use clipboard instead of download to avoid navigation issues
  if (typeof window !== 'undefined' && window.Telegram?.WebApp) {
    return copyConversation(messages, language);
  }
  
  // Regular browser download
  const content = exportConversation(messages, language);
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  const filename = `sobesednik-${new Date().toISOString().split('T')[0]}.txt`;
  
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export function copyConversation(messages: Message[], language: 'en' | 'ru'): Promise<void> {
  const content = exportConversation(messages, language);
  return navigator.clipboard.writeText(content);
}
